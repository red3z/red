| CAP理论                           |                                                 |
| --------------------------------- | ----------------------------------------------- |
| 一致性（Consistency）             |                                                 |
| 可用性（Availability）            | 每次请求都会得到响应, 无论成功或者失败.         |
| 分区容错性（Partition tolerance） | 网络故障导致结点之间无法通信, 系统仍然继续运行. |

只能保证2个, 一般保证CP或AP.



# 分布式的风险

1. 引入了第三方, 用集群保证高可用
2. 数据不一致, 补偿
3. 性能: 降低.



# 分布式锁

## Redis实现分布式锁

Redis实现分布式锁: 性能高, 一致性.

在分布式场景下中, 有多个客户端的线程访问共享资源时, 需要分布式锁. 比如说秒杀会有多个服务器来抢一个商品.

set key1 value1 nx; setnx(Set if Not Exists)命令是当key1不存在的时候才会执行, 如果key1存在则什么都不干

最简单的分布式锁: 客户端1设置了key1, 客户端2就不能设置key1了, 当客户端1执行完后, 将key1删除, 客户端2就可以设置key1了. 

| 问题                                                         | 解决方式                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 客户端1上锁后, 客户端1挂了, 锁无法被释放                     | 设置过期时间                                                 |
| 客户端1上锁后, 客户端1卡了, 锁过期, 客户端2设置了锁, 客户端1把客户端2的锁删了, 这对吗? | Java程序可以获取uuid, 设置<锁, uuid>. 如果要删除, 需要先判断 锁的value是不是我自己的uuid. |
| 删除前判断要get, get完又要del, 所以是两步操作                | 用lua脚本                                                    |
| 锁的过期时间怎么评估?                                        | 业务起一个守护线程(看门狗线程)定时运行去Redis检测代表锁是否失效, 如果发现锁还在, 说明持有锁的进程还没运行完, 则需要给key续期. |
| 客户端1挂了, 守护线程一直给锁续期, 导致死锁                  | 为锁设置一个合理的最大持有时间, 并在业务逻辑中实现超时处理机制 |
| Redis只有一台挂了咋办?                                       | Redis集群                                                    |
| 集群情况下, 对主结点加锁, 还没同步到从结点, 主结点挂了. 会丢失1s的锁 | 红锁RedLock, 保证所有结点都存储完毕才会响应, 从而保证强一致性. |

分布式系统中确保每个元素都有一个唯一的标识符uuid，从而避免出现名称重复的问题



## Zookeeper实现分布式锁

Zookeeper实现分布式锁: Zookeeper集群一半同步成功才返回成功, 可保证较高一致性.



# 分布式事务

一个请求的业务需要多个服务共同完成, 每个服务都有自己的数据库.

本质上有两种解决方案: 1.协调事务; 2.最终一致性. 



## 强一致性

问题:

1. 单点故障. 解决方案: 集群
2. 没提交的时候数据库连接无法释放, 性能低. 解决方案: 释放连接, 存储前后镜像.
3. 网络不可靠导致数据不一致. 协调者通知所有服务可以提交, 有些服务没受到. 解决方案: 人工用脚本补偿.



### XA模式

两阶段提交.

第一阶段: 每个结点执行事务, 先不提交, 需要设置串行化, 阻塞其他事务.

第二阶段: 提交.

代码没有侵入, 在编写代码上和AT一模一样, 可以和AT模式简单切换, 觉得性能差改配置文件就行.



三阶段提交, 相对于两阶段提交的改进点:

1. 数据库连接资源的占用. 第一阶段先评估这个事务能不能成功, 之后再两阶段提交.
2. 超时后的处理. 协调者发送来的确认提交通知超时后, 提交, 不考虑回滚.



## 最终一致性

### AT

 对sql分析, 反向生产SQL, 如果用AT, 需要有个UNDO_LOG表, 对sql执行前后的数据镜像进行保存, 生成回滚日志. 优点是代码无侵入, 但是必须基于关系型数据库.



### TCC

手动写一套存储状态, 确认, 回滚的代码.

TCC模式: try confirm cancel. 阻塞粒度变小了.

try: 如果事务要查一条数据, 就先插一条试试, 但是将enable=false. 要该一个字段, 则需要新增一个冻结字段, try就是先写冻结字段.

confirm: 将enable=true.

cancel: 如果有一个不行, 则cancel.



### SAGA

流水线式, 一般用于涉及到第三方.

执行的时候就当没有分布式事务, 如果出了问题, 协调者发送一个反向回滚.

基于状态机执行一个已经定义好流程的Json文件, 来控制整个流程的提交, 回滚的方式, 也需要侵入代码.



我的支付服务 --> 支付宝服务. 支付宝收到后会回调我的服务通知我们钱收到了. 最大努力通知, 会通知我们很多次. 我的服务提供回查, 支付宝查这个事务要做的事情, 支付宝保证成功就行.



### 使用MQ

发送预备消息(半消息), 不会被消费者消费. 

MQ回复预备消息的确认, 生产者执行事务. 如果事务失败, 则删除预备消息.

生产者执行完事务后, 对半消息进行确认

消费者执行事务. 如果事务失败, 说明是代码的问题. 如果没执行, 是网络问题, 重试. 如果都不行, 人工补偿.



本地消息表, A执行事务, 将消息放入本地消息表, A的定时任务读本地消息表放入MQ, B执行事务. 如果B失败则重试, 一直失败则人工介入.







# 分布式id

分布式id需要满足全局唯一, 高性能, 高可用, 为了安全不可预测.

| 分布式id的方案                 | 优点               | 缺点                         |
| ------------------------------ | ------------------ | ---------------------------- |
| UUID                           | 简单, 可以本地生成 | 无序, 没有业务含义, 长度太长 |
| Redis自增                      |                    |                              |
| 雪花算法(时间戳+机器id+序列号) |                    |                              |

分布式id的解决方案, 跟算法没什么关系, 雪花算法是主键解决方案, 例如订单表的主键不会用订单号, 因为主键的含义是这张表唯一的标识或者说流水号, 没有业务含义. 能不能用主键做业务Id?是可以的, 小型系统可以这么做. 但在大型分布式系统里一般都有个分布式Id的生成服务, 这个服务用什么算法都和我们没关系, 但是要保证这个id在这个业务里是唯一的, 也就意味着这个id不管在物流, 支付系统, 都可以唯一标识这个订单, 有些订单号还会加字符串, 例如快递单号. 做关联查询的时候, 最好方案是根据业务id.

需要分库分表的时候, 不管怎样数据都会在重新散列一遍, 需要考虑引入一个横向扩展的分布式数据库.



# 一致性哈希进行数据分片

多台服务器怎么分配请求? 负载均衡, 轮询或者根据硬件加权轮询, 

加权轮询的前提是每个结点数据相同, 但如果是<u>数据分片</u>, 每个结点数据不同. 

所以需要根据数据哈希, 来确定访问哪个结点.



| 数据分片算法       |                                                              |
| ------------------ | ------------------------------------------------------------ |
| 哈希算法           | 对结点数量取模, 当结点数量发生改变时, 也就是对系统扩容缩容, 需要迁移数据. 最坏情况下所有数据都需要迁移. |
| 一致性哈希         | 对2^32^取模. 所有数据映射在一个环上, 顺时针找到的第一个结点就是该数据要存的结点. 结点数量更改时, 仅会有部分数据需要迁移. 缺点是存在结点分布不均匀的问题, 可能所有数据都在一个结点上, 而且增加结点只分摊了下一个结点的存储压力; |
| 虚拟一致性哈希分区 | 一个结点对应多个虚拟结点, 均匀在环上分布. 数据先映射到虚拟结点, 再通过虚拟结点映射到实际结点. |

引入虚拟结点, 可以提高结点均衡度, 还会提高系统稳定性. 比如当某个结点移除时, 对应的虚拟结点也会移除, 这些虚拟结点的顺时针方向的下一个虚拟结点, 可能会对应不同的真实结点, 不同的真实结点分摊了结点变化导致的压力.



# 分布式幂等

# 分布式日志

# 分布式链路追踪

# 分布式定时任务

# 分布式预警监控

# 分布式数据库

# 分布式搜索引擎







