| CAP理论                                   |                                                 |
| ----------------------------------------- | ----------------------------------------------- |
| 一致性（Consistency）                     |                                                 |
| 可用性（Availability）                    | 每次请求都会得到响应, 无论成功或者失败.         |
| (必选项)分区容错性（Partition tolerance） | 网络故障导致结点之间无法通信, 系统仍然继续运行. |

只能保证2个, 一般保证CP或AP.



# 分布式的风险

1. 引入了第三方, 用集群保证高可用
2. 数据不一致, 补偿.
3. 性能: 降低.



# 01 分布式锁

## Redis实现分布式锁

Redis实现分布式锁: 性能高.

无论哪个JVM里面的哪个线程拿到分布式锁, 都不能继续执行, 用setnx实现(当Redis中有这个值的时候, 设置失败返回0; 当没有这个值的时候设置成功返回1), 根据setnx的返回值判断是否获取到了锁.

在分布式场景下中, 有多个客户端的线程访问共享资源时, 需要分布式锁. 比如说秒杀会有多个服务器来抢一个商品.

set key1 value1 nx; setnx(Set if Not Exists)命令是当key1不存在的时候才会执行, 如果key1存在则什么都不干

最简单的分布式锁: 客户端1设置了key1, 客户端2就不能设置key1了, 当客户端1执行完后, 将key1删除, 客户端2就可以设置key1了.

| 问题                                                         | 解决方式                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 客户端1上锁后, 客户端1挂了, 锁无法被释放                     | 设置过期时间                                                 |
| 客户端1上锁后, 客户端1卡了, 锁过期, 客户端2设置了锁, 客户端1把客户端2的锁删了, 这对吗? | Java程序可以获取uuid, 设置<锁, uuid>. 如果要删除, 需要先判断 锁的value是不是我自己的uuid. |
| 释放锁, 也就是删除前判断要get, get完又要del, 是两步操作      | 用lua脚本                                                    |
| 锁的过期时间怎么评估?                                        | 业务起一个看门狗线程定时运行去Redis检测代表锁是否失效, 如果发现锁还在, 说明持有锁的进程还没运行完, 则需要给key续期. |
| 客户端1挂了, 守护线程一直给锁续期                            | 看门狗线程设置为业务线程的守护线程, 业务线程挂了, JVM自动终止守护线程. |
| 锁的可重入                                                   | Redission的实现方案: <锁, <线程id_uuid, 重入次数>>用hsetnx;  |
| 抢不到锁怎么办?                                              | 可以自旋; Redission的实现方案: Redis的发布订阅机制, 没抢到的会订阅然后阻塞, 持有锁的线程结束后发布一条消息, 并且设置最大等待时间. |
| Redis只有一台挂了咋办?                                       | Redis集群                                                    |
| 集群情况下, 对主结点加锁, 还没同步到从结点, 主结点挂了. 会丢失1s的锁 | 红锁RedLock, 保证半数以上加锁成功, 因为有一个线程保证半数以上加锁成功, 就可以保证其他线程都做不到半数成功. |
| 不同节点的系统时钟不一样, 并且Java的GC会暂停线程, 导致看门狗无法对锁续期, 锁就过期了 |                                                              |

分布式系统中确保每个元素都有一个唯一的标识符uuid，从而避免出现名称重复的问题



## Zookeeper实现分布式锁

Zookeeper实现分布式锁: Zookeeper集群一半同步成功才返回成功, 可保证较高一致性.

如果获取不到锁, 只需要添加监听器, 不需要一直轮询, 性能消耗小.



# 02 分布式事务

数据库分库分表时, 涉及到多个数据库共同组成的事务, 就是分布式事务.



## 2-1 强一致性(遵循CP)

问题:

1. 单点故障. 解决方案: 集群
2. 没提交的时候数据库连接无法释放, 性能低. 解决方案: 释放连接, 存储前后镜像.
3. 网络不可靠导致数据不一致. 协调者通知所有服务可以提交, 有些服务没受到. 解决方案: 人工用脚本补偿.



### 2-1-1 XA协议

XA协议是一个基于数据库层面的分布式事务协议, Oracle、MySQL等数据库均已实现了XA接口

#### 2PC

两阶段提交协议2PC: 根据XA协议衍生出来的

第一阶段: 每个结点执行事务, 先不提交, 需要设置串行化, 阻塞其他事务.

第二阶段: 提交.

代码没有侵入, 在编写代码上和AT一模一样, 可以和AT模式简单切换, 觉得性能差改配置文件就行.



#### 3PC

三阶段提交协议3PC: 2PC的优化

1. 数据库连接资源的占用. 第一阶段先评估这个事务能不能成功, 之后再两阶段提交.
2. 超时后的处理. 协调者发送来的确认提交通知超时后, 提交, 不考虑回滚.





### 事务状态表

| 分布式事务 ID   | 事务内容                    | 事务状态                                             |
| --------------- | --------------------------- | ---------------------------------------------------- |
| global_trx_id_1 | 操作1: 调用A; 操作2: 调用 B | 状态1: 初始; 状态2: 操作1成功; 状态3: 操作1、2都成功 |

有了这张表，就可以启动一个后台任务，扫描这张表中事务的状态，如果一个分布式事务一直未到状态 3，说明这条事务没有成功，于是可以重新调用 A, B。直至所有的调用成功，事务状态到 3。

如果多次重试仍未使得状态到 3，可以将事务状态置为 error，通过人工介入进行干预。



## 2-2 最终一致性(遵循AP)

基于业务层考虑

### TCC

可理解为应用层面的2PC

TCC模式, 或者说补偿事务: Try Confirm Cancel. 阻塞粒度变小了. 广泛用于金融系统.

手动写一套存储状态, 确认, 回滚的代码.

try: 如果事务要查一条数据, 就先插一条试试, 但是将enable=false. 要该一个字段, 则需要新增一个冻结字段, try就是先写冻结字段.

confirm: 将enable=true.

cancel: 如果有一个不行, 则cancel.

还需要保证confirm和cancel操作的幂等.

### SAGA



### MQ实现分布式事务

方式1:预备消息

发送预备消息(半消息), 不会被消费者消费. 

MQ回复预备消息的确认, 生产者执行事务. 如果事务失败, 则删除预备消息.

生产者执行完事务后, 对半消息进行确认

消费者执行事务. 如果事务失败, 说明是代码的问题. 如果没执行, 是网络问题, 重试. 如果都不行, 人工补偿.



方式2:本地消息表

A执行事务, 将消息放入本地消息表, A的定时任务读本地消息表放入MQ, B执行事务. 如果B失败则重试, 一直失败则人工介入.

优点: 响应速度快; 缺点: 编码复杂, 排查问题困难.



## Seata

| Seata |                                                              |
| ----- | ------------------------------------------------------------ |
| AT    | 对sql分析, 反向生产SQL, 如果用AT, 需要有个UNDO_LOG表, 对sql执行前后的数据镜像进行保存, 生成回滚日志. 优点是代码无侵入, 但是必须基于关系型数据库. |
| TCC   |                                                              |
| SAGA  | 流水线式, 一般用于涉及到第三方. 执行的时候就当没有分布式事务, 如果出了问题, 协调者发送一个反向回滚. 基于状态机执行一个已经定义好流程的Json文件, 来控制整个流程的提交, 回滚的方式, 也需要侵入代码. 当 我的支付服务 --> 支付宝服务. 支付宝收到后会回调我的服务通知我们钱收到了. 最大努力通知, 会通知我们很多次. 我的服务提供回查, 支付宝查这个事务要做的事情, 支付宝保证成功就行. |
| XA    |                                                              |



# 03 分布式id

分布式id需要满足全局唯一, 为了安全不可预测, 高性能, 高可用.

| 分布式id的方案                        | 优点               | 缺点                                  |
| ------------------------------------- | ------------------ | ------------------------------------- |
| UUID                                  | 简单, 可以本地生成 | 太长且无序, 没有业务含义,             |
| Redis自增                             | 高性能             | 依赖Redis                             |
| Twitter雪花算法(时间戳+机器id+序列号) |                    | 需要独立开发部署, 机器时钟可能有偏差. |
| 百度UidGenerator                      |                    |                                       |
| 美团Leaf                              |                    |                                       |

分布式id的解决方案, 跟算法没什么关系, 雪花算法是主键解决方案, 例如订单表的主键不会用订单号, 因为主键的含义是这张表唯一的标识或者说流水号, 没有业务含义. 能不能用主键做业务Id?是可以的, 小型系统可以这么做. 但在大型分布式系统里一般都有个分布式Id的生成服务, 这个服务用什么算法都和我们没关系, 但是要保证这个id在这个业务里是唯一的, 也就意味着这个id不管在物流, 支付系统, 都可以唯一标识这个订单, 有些订单号还会加字符串, 例如快递单号. 做关联查询的时候, 最好方案是根据业务id.

需要分库分表的时候, 不管怎样数据都会在重新散列一遍, 需要考虑引入一个横向扩展的分布式数据库.



# 04 一致性哈希进行数据分片

多台服务器怎么分配请求? 负载均衡, 轮询或者根据硬件加权轮询, 

加权轮询的前提是每个结点数据相同, 但如果是<u>数据分片</u>, 每个结点数据不同. 

所以需要根据数据哈希, 来确定访问哪个结点.

| 数据分片算法       |                                                              |
| ------------------ | ------------------------------------------------------------ |
| 哈希算法           | 对结点数量取模, 当结点数量发生改变时, 也就是对系统扩容缩容, 需要迁移数据. 最坏情况下所有数据都需要迁移. |
| 一致性哈希         | 对2^32取模. 所有数据映射在一个环上, 顺时针找到的第一个结点就是该数据要存的结点. 结点数量更改时, 仅会有部分数据需要迁移. 缺点是存在结点分布不均匀的问题, 可能所有数据都在一个结点上, 而且增加结点只分摊了下一个结点的存储压力; |
| 虚拟一致性哈希分区 | 一个结点对应多个虚拟结点, 均匀在环上分布. 数据先映射到虚拟结点, 再通过虚拟结点映射到实际结点. |

引入虚拟结点, 可以提高结点均衡度, 还会提高系统稳定性. 比如当某个结点移除时, 对应的虚拟结点也会移除, 这些虚拟结点的顺时针方向的下一个虚拟结点, 可能会对应不同的真实结点, 不同的真实结点分摊了结点变化导致的压力.



# 04 分布式幂等

查询和删除数据没有幂等问题.

| 幂等的解决方案           |                                                              |
| ------------------------ | ------------------------------------------------------------ |
| 数据库解决新增的幂等问题 | 数据建立唯一索引, 当插入数据异常时说明数据已经存在, 将要插入的数据查出来返回. |
| 缓存解决修改的幂等问题   | 后端存一个token, 每次前端发请求带上这个token, 操作完后后端把这个token删掉, 如果重复请求, 发现token无效, 就不执行. |
| 加锁                     | 悲观锁, 乐观锁, 分布式锁                                     |



# 分布式日志

# 分布式定时任务

# 分布式链路追踪

# 分布式预警监控

# 分布式数据库

# 分布式搜索引擎







