# 消息中间件的作用

- 异步与解耦
- 流量削峰
- 数据分发: A系统需要对接多个系统B, C, D
  - 没有MQ: A调用B, 调用C, 调用D
  - 有MQ: A系统生产数据发送到MQ, 其他系统从MQ中消费



# 常见消息中间件的比较

|        | RabbitMQ                         | Kafka              | RocketMQ       |
| ------ | -------------------------------- | ------------------ | -------------- |
| 并发量 | 6000~12000/s                     | 百万               | 10w/s          |
| 语言   | Erlang, 出了问题看不懂Erlang源码 | 多语言, 涉及大数据 | 纯java, 偏电商 |



# RabbitMQ的AMQP

Advanced Message Queue Protocol

| RabbitMQ的组件 |                                                              |
| -------------- | ------------------------------------------------------------ |
| Channel        | 生产者消费者与RabbitMQ的Broker通信通过Channel. 一个TCP连接中有多个Channel |
| Exchange交换器 | Exchange与Queue Binding在一起.                               |
| Queue          |                                                              |

消费者监听某个Channel, 收到消息, 会将消息删除.



| RabbitMQ的消息丢失               | 解决方式                        |
| -------------------------------- | ------------------------------- |
| 生产者发送到Exchange的时候可能丢 |                                 |
| Exchange与Queue绑定关系出错      |                                 |
| MQ断电则会丢                     | 持久化                          |
| 消费者出现异常                   | 手动确认, 消费逻辑成功后再确认. |



# Kafka的核心组件

| Kafka的组件 |                                                              |
| ----------- | ------------------------------------------------------------ |
| Zookeeper   | Kafka集群时, 每台kafka的ip, 端口, Topic管理                  |
| Broker      | 集群的话会有多个服务器, 每台服务器叫一个broker               |
| Topic       | 队列可能有多个, 所以给每个队列起个名字, 就是topic. 生产者生产消息时指定topic, kafka就会帮助我们将消息分配到partition上 |
| Partition   | 为了提高吞吐量, 一个Topic分成多个Partition, 消费者从partition中拿. 有多个Partition就能同时有多个消费者消费同一个Topic中的数据, 一个Partition不能给两个消费者消费 |
| Group       | 消费者组. 一个消费者组对应一个goupID, 一条消息可以被多个不同的Group消费, 一个消费者组中只有一个消费者消费这个消息. kafka不会因为消费而删除数据, 所以每一个消费者组会==全量地==拿到topic的数据. Group记录着Topic中的某个Partition分区的偏移量，下次消费组中的消费者直接从偏移量处消费 |



# RocketMQ的核心组件

| RocketMQ组件 |                |
| ------------ | -------------- |
| NameServer   | 服务注册与发现 |
| Netty        |                |
| Heartbeats   | 心跳确认存活   |



# RocketMQ底层刷盘机制

同步刷盘: 生产者发送消息后, Broker 将消息写入内存（PageCache）, 并**立即将数据刷写到磁盘**。只有磁盘写入成功后，才会向生产者返回成功响应。

异步刷盘: 生产者发送消息后, Broker 将消息写入内存（PageCache）, 并**立即向生产者返回成功响应**。磁盘刷盘操作由后台线程异步完成。



# RocketMQ集群分片机制

将 Topic 划分为多个队列, 将队列分布到不同的 Broker 上.

NameServer 负责维护 Topic 和 Broker 的路由信息。



# 延时消息

有些消息经过指定时长, 会达到死信队列, 消费者消费死信队列中的内容.



# 消息丢失问题

| 产生消息丢失的情                                             | 解决方法                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 生产者                                                       | 受到MQ的确认信息才算发送成功, 没收到重发.                    |
| MQ: 消息数据放在磁盘中, 默认采用异步刷盘的策略, 即收到消息后, 将数据放到内存, 直接返回确认信息. 如果此时MQ挂了, 消息丢失 | 采用同步刷盘可以保证消息不丢失. 磁盘坏了, 怎么保证消息不丢失? 主从架构. |
| 消费者: 只要获取到消息, 就算成功, 如果此时消费者挂了, 则消息丢失. | 只有当消息成功处理后, 才去返回一个确认信息.                  |

RocketMQ三种消息发送方式: 

1. 同步: 发送消息阻塞当前生产者线程, 等拿到MQ返回的确认信息后才结束. 
2. 异步: 构建发送消息任务, 然后将任务放到线程池. MQ处理完后回调函数返回给生产者结果.
3. Oneway发送: 只发, 不管返回结果.



# 重复消费问题 (幂等)

幂等处理, 消费端业务上处理.

| 处理幂等的两种方式 |                                                              |
| ------------------ | ------------------------------------------------------------ |
| MVCC               | 每条SQL都比对版本号, 多次执行同一条SQL只生效1次. 缺点: 涉及业务改动, 每条消息都要一个版本号, 还要保证版本号不重复(涉及分布式Id) |
| 去重               | MySQL额外一张去重表, 只有orderId字段(unique的), 产生一个新订单时, 扣减库存之前, 先将orderId插入这张去重表, 如果异常则不进行后续业务 |
| Redis去重          | Redis的Set实现去重.                                          |



# 消息积压问题

如何平衡生产者和消费者的速度? 测试一下1000个请求生产者大概多久可以执行完, 从而根据实际的请求量调整线程池.

| 出现消息积压问题的原因 |                                                              |
| ---------------------- | ------------------------------------------------------------ |
| JVM处理慢              | 普通业务JVM一般不是瓶颈, 除非涉及到密集运算, 或者大数据量处理, 只能加机器处理. |
| 数据库新增慢           | 新增不锁行, 可能是因为表的索引太多导致新增性能下降,          |
| 数据库更新慢           | 对同一行记录的更新操作慢, 因为更新会锁行, 解决方案是把数据分散在几条记录里. |
|                        | 引入分布式数据库的中间件, Mycat.                             |
|                        | 直接引入分布式数据库比如MongoDB, ES.                         |
| 依赖的外部慢           | 如果是外部依赖问题, 只能对外部提要求, 非实时场景可以要求外部提供异步能力, 给他们提供回调入口操作. |



# 消息顺序问题



# 延时消息

提交了一个订单, 必须在5分钟内完成支付, 此时需要锁库存, 5分钟后没支付需要将库存释放.

实现方式: 提交订单后, 锁库存, 并向MQ发送一条==延时消息==. 消费者5分钟后收到消息, 如果支付了则不管; 如果未支付, 则去释放库存.









