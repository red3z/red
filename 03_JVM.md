---
title: 一篇文章讲完JVM
tags:
  - null
categories:
  - Java基础
mathjax: true
description: JVM相关知识
abbrlink: 584298a6
date: 2024-11-06 11:39:21
---



JVM用来执行class文件, 帮助我们屏蔽底层操作系统, 实现跨平台, 一次编译, 到处运行. 



# Java编译与执行

| JDK相关概念 |                                                              |
| ----------- | ------------------------------------------------------------ |
| JVM         | 是一个抽象的计算机(冯诺依曼结构), JVM实现跨平台, 把.class文件翻译成当前操作系统的可执行文件并执行 |
| JDK         | Java Development Kit, JDK = JRE + development kit            |
| JRE         | Java Runtime Environment, Java运行环境. JRE = JVM + core lib. core lib里面包含String.class, Object.class等核心类 |
| JIT         | Just-In-Time compiler, JIT即时编译器把.class文件编译成本地代码(可以在当前系统直接运行, 而不需要在JVM上运行) |



JVM是干啥的?  

帮我们屏蔽操作系统, 不同操作系统下载相对应的JDK, 里面就有适配当前系统的JVM. .java被编译为.class, .class运行在JVM上, 适配当前系统的JVM将.class解释成 当前系统的指令执行.

| .java到执行的过程 |                                                              |                    |
| ----------------- | ------------------------------------------------------------ | ------------------ |
| 1. 编译           | .java --> .class                                             | 泛型的擦除, Lombok |
| 2. 加载           | 类加载, 将编译后的class文件加载到JVM方法区内, 在堆区创建一个Class对象 |                    |
| 3. 解释           | 把.class字节码转换为操作系统识别的指令                       |                    |
| 4. 执行           | 操作系统把解释器解析出来的指令码, 调用系统的硬件执行最终的程序指令 |                    |





# 类加载机制

## 类加载过程

|                   |                                                              |
| ----------------- | ------------------------------------------------------------ |
| 累加载是干啥?     | 把.class加载到JVM内存, 并且将.class转换成直接使用的Java类型, 即java.lang.Class. |
| 什么时候会类加载? | 类(子类)的实例化, 访问静态==成员==, 反射加载类, JVM启动时加载部分类 |

java操作数据其实是用对象操作, 也就是如果想要访问某个数据结构, 一定要有个对象引用指向它. 在java堆中生成一个代表这个类的Class对象, 作为方法区的数据访问入口.



**类加载的过程**

| 类加载的过程       |                                                              |
| ------------------ | ------------------------------------------------------------ |
| Loading加载:       | 用类加载器将磁盘中的.class加载到JVM内存. 将.class转化为Class(类信息)存储在==方法区==, 在堆中生成一个便于用户调用的`Java.lang.Class`类型的对象. 模板性数据放在方法区, 业务数据放在堆中. |
| Linking连接        | 分配内存空间并对其赋默认值. 1.验证该class是否符合JVM标准; 2.静态变量==赋默认值==; 3.将类, 方法, 属性等符号引用替换为直接引用(内存地址), 常量池中的各种符号引用解析为指针, 偏移量等内存地址的直接引用 |
| Initializing初始化 | 先初始化父类, 再对子类 静态变量赋初始值, 执行静态代码块,     |



**Class对象在堆还是在方法区?**

对象的Markword存放==方法区==的C++对象地址, 这个C++对象包含了指向存在==堆==中的Class对象



## 类加载器

| 类加载器          |                                     |
| ----------------- | ----------------------------------- |
| BootStrap         | 加载lib/rt.jar charset.jar, C++实现 |
| Extension         | 加载jre/lib/ext/*.jar               |
| Appication        | 加载classpath                       |
| CustomClassLoader |                                     |

误区: 与父加载器不是继承关系, 父加载器也不是类加载器的加载器. JDK1.8通过依赖关系设置子父类关系.

Tomcat使用了自定义类加载器, 因为Tomcat内部可能启动了多个不同的Java进程, 不同的Java进程可能会出现同一个类名.



## 双亲委派机制

**双亲委派的过程**

类加载器收到类加载请求时, 先请求父类加载器去检查是否加载过, 直到最上层; 当父类加载器无法加载该类时, 父类委托子类加载器加载.

双亲说的是子到父检查, 父再到子加载



**为什么要双亲委派?**

1. 为了安全, 如果没有的话, 自己可以写String类
2. 避免类的重复加载



java.jdbc.Driver是数据库驱动接口, 由BootStrap加载器加载, 但是java.jdbc.Driver接口的实现是数据库厂商写的, 应该用Application加载器加载. JVM引入线程上下文类加载器, 把原本需要BootStrap加载的类由Application加载. java.lang.Thread的setContextClassLoader()设置当前类的类加载器.



**如何打破双亲委派?**

重写loadClass(), 可以自定义要加载的类使用的类加载器

Thread.setContextClassLoader()设置当前类使用的类加载器, SPI



# JVM内存模型

| JVM               |                                                              |
| ----------------- | ------------------------------------------------------------ |
| 堆                |                                                              |
| 栈                |                                                              |
| Direct Memory     | 一些网络编程框架如Netty会使用, 用 -XX:MaxDirectMemorySize参数控制 |
| JNI Native Memory | 一些通过JNI实现的库会使用, 如 压缩用到的Deflater             |
| 方法区            | 方法区是规范, 永久代(存在JVM内存)和元空间(存在JVM之外的内存)是具体实现 |
| 程序计数器        | 记录每个线程执行到哪了                                       |
| 本地方法栈        | 本地方法就是`native`关键字修饰的方法                         |



哪些区会出现OOM?

栈的无限递归, 堆的对象太多, 方法区



**栈帧是什么?**

栈帧是栈中的一个栈元素, 栈帧包含了方法的信息



## 常量池

存放常量, Class对象, 静态变量. 常量池包括运行时常量池, class文件常量池, 字符串常量池, 基本数据包装类常量池

| 常量池有哪些?        |                                                              |
| -------------------- | ------------------------------------------------------------ |
| 静态常量池           |                                                              |
| 运行时常量池         | 静态常量池加载到内存就是运行时常量池.                        |
| class文件常量池      | 类信息: 字段, 方法, 接口, 父类.                              |
| 字符串常量池         | 1.6在方法区(永久带); 1.7在堆.                                |
| 基本数据包装类常量池 | Float和Double这种小数类的没有常量池; Byte,Short,Integer,Long: [-128~127]; Character :[0~127];  Boolean :[True, False] |



## Object

对象的生命周期

1. 分配存储空间
2. 父类到子类类加载
3. 父类到子类执行构造方法
4. 变量指向了其他东西, 不可见
5. 不可达.



| 一个对象在内存中                    |                                                              |
| ----------------------------------- | ------------------------------------------------------------ |
| Markword大小8B                      | 记录垃圾回收器的信息: 三色的颜色信息, 分代年龄, 锁信息, Hashcode信息 |
| Class pointer默认大小4B, 关闭压缩8B |                                                              |
| Instance data                       |                                                              |
| Padding保证对象大小能被8B整除       | 8B是64位操作系统一次寻址的最小单位.                          |



| Object                                           |                                                              |
| ------------------------------------------------ | ------------------------------------------------------------ |
| Java一个指针占多少字节?                          | 64位虚拟机默认开启压缩, 一个指针是4个B. 关闭压缩则是8个B     |
| 对象怎么定位?  `T t = new T();`t是怎么找到对象的 | 直接指针: t指向堆中new出来的空间, 这个空间内有Classpointer指向方法区中的`T.class`. 间接指针: GC回收较快. |
| 对象怎么分配?                                    | 对其进行分析, 如果可以的话在栈上分配; 判断这个对象大不大, 大的话放在老年代; TLAB(Thread Local Application Buffer): 防止好多线程往伊甸园区放对象, 出现锁竞争影响效率. TLAB为每个线程分配一个私人空间; 经过垃圾回收一次后, 去往Survival区 |
| 往栈上分配对象的标准是什么?                      | 逃逸分析: 如果这个对象只在方法局部使用, 方法结束可以随着方法一起弹出栈. 标量替换 |



# GC

## 垃圾

| 程序中的垃圾        |                                                              |
| ------------------- | ------------------------------------------------------------ |
| 什么是垃圾?         | 没有引用指向的内存地址(或者说对象), 就是垃圾                 |
| 怎么找到垃圾?       | 根可达算法. 根包括main方法. 栈里的本地变量, 方法区的静态属性, 方法区的常量, native引用的对象. |
| 什么时候会回收垃圾? |                                                              |

Python使用引用计数法, 每个引用都有一个计数器记录引用他的数量, 数量为0的就是垃圾. 无法找到循环引用的垃圾.



## 垃圾回收算法

| 垃圾回收算法 | 三种垃圾回收算法组合诞生垃圾回收器                           | 缺点       |
| ------------ | ------------------------------------------------------------ | ---------- |
| 标记清除     | 找到垃圾直接干掉.                                            | 内存碎片化 |
| 标记复制     | 设定一些内存不允许使用, 活着的对象放到不可用内存中, 然后将可用内存全部清除. | 浪费内存   |
| 标记整理     | 清理后, 再整理好.                                            | 效率低     |
| 分代收集算法 | 年轻代: 标记复制; 老年代: 标记清除或标记整理.                |            |

内存碎片化时, 分配内存的方法:

1. 首次适应
2. 最佳适应
3. 最差适应



## JVM内存分区

- 新生代: 
  - Eden: 刚出生的对象
  - Suvivor: 扛住GC扫描的对象, 有两个Suvivor, 用来解决内存碎片化.
- Old: 扛住16次扫描的对象, 在Old



老年代内存担保机制? 对象太大了, 直接进入Old.



## 垃圾回收器

JVM的垃圾回收器基于分代设计, 没有经历过垃GC扫描的对象为新生代, 经历过的对象叫老年代, 90%的对象一次就被回收

| 垃圾回收器随着内存的增长演化     |                                                              |
| -------------------------------- | ------------------------------------------------------------ |
| Parallel Scavenge + Parallel Old | (JDK8默认)新生代复制 + 老年代整理. GC需要STW, STW时间较长, 适合内存要求高的项目. |
| ParNew + CMS                     | 新生代复制 + 老年代清除. 业务线程运行时GC, 部分需要STW, STW时间短, 适合并发度高的项目. |
| G1                               | G1将内存等分成块, 叫作region. 屏弃了分区思想, 物理不分代, 逻辑分代. 可根据设定的最大停顿时间, 动态调整每次回收的region数量; 清理时业务逻辑不用停; |
| ZGC(JDK 17才支持)                | 几乎完全并发, STW时间短.                                     |



CMS(Concurrent Mark Sweep)
1. 初始标记: STW找到根
2. 并发标记: 执行业务的同时标记垃圾
   - 会出现标记错的情况例如:垃圾在运行过程中又有个引用指向他, 又不是垃圾了(缓存命中, 没命中的要清除了, 突然又来了个命中了; 重写了`finalize()`,死了的对象又给复活了); 本来不是垃圾, 运行过程中引用没有了, 又变成垃圾了; 
3. 重新标记: STW, 修正标错的垃圾(必须从头扫描, 但是第二阶段并发标记仍然有用, 因为梳理了相关的内容, 简化了一些东西)
4. 并发清除

| CMS的三色标记算法 | Concurrent Mark Sweep                                        |
| ----------------- | ------------------------------------------------------------ |
| 用在什么时候      | 三色标记<u>用在并发标记阶段</u>                              |
| 用来干什么        | GC线程受操作系统调度隔一段时间运行一段, 所以需要保存运行状态, 用三色标记算法来记录状态 |
| 三色              | 黑色: 自己标记了, 孩子(Fields)也标记了, 不再扫描; 灰色: 自己标记了, 孩子(Fields)还没, 扫描孩子; 白色: 没有标记到的结点; |
| 注意事项          | 当某个黑色对象的孩子指向新的对象, 黑色对象变为灰色           |
| 无法解决的Bug     | 多个GC线程存在无法解决的Bug                                  |

G1解决三色标记算法并发问题: 三色标记算法 + SATB(Snapshot At the Begining)来解决并发存在的问题, 当业务线程执行了引用的改变时, 这个修改记录会被记录下来, GC线程根据记录来继续下一步的垃圾回收.



# JVM调优

| JVM调优是做什么?     | 目的是调整参数从而达到充分利用硬件.                          |
| -------------------- | ------------------------------------------------------------ |
| 根据需求进行JVM规划  | 用什么机器, 用多少内存                                       |
| 解决JVM运行慢的问题  | 定位系统的瓶颈要使用压力测试: 单机通过方法跟踪; 分布式需要用skywalking之类的工具进行全链路压测来找出哪个服务慢. |
| 解决运行过程中的问题 | Memory Leak, OOM                                             |



| JVM常用命令       |                                             |
| ----------------- | ------------------------------------------- |
| jps               | (JVM Process Status)列出有哪些Java进程      |
| jinfo 进程id      | Java进程的详细信息, 包括垃圾回收器, 堆内存, |
| jstate -gc 进程id | (JVM Statistics)查看gc的情况                |
| jstack            | 查看线程情况, 会检测到死锁并输出.           |
| jmap              | 查看堆情况                                  |



## 频繁minor gc怎么办?

增大新生代空间



## 频繁full gc怎么办?

频繁full gc问题很严重, 可能是大对象进入了老年代, 可能是内存泄露.



## OOM问题定位

| 查看堆的情况的命令                       |                           |
| ---------------------------------------- | ------------------------- |
| jmap -histo 进程id                       | 查看每种class有多少个实例 |
| jmap -dump:format=b, file=20240801.hprof | 将整个堆导成一个文件      |

| 如何查看JVM堆情况?(生产环境不能直接导文件, 因为会使程序卡死) |      |
| ------------------------------------------------------------ | ---- |
| 在压力测试环境里挂了一个图形化工具, 远程观察                 |      |
| 做了负载均衡, 把其中一台的堆转储文件导出来                   |      |
| `tcp copy` 在线服务器部署, 捕获请求包, 修改TCP/IP头部信息, 将线上流量一份打到生产环境, 一份打到测试环境里 |      |



## CPU飙高问题定位

1. top 查看所有进程CPU占用情况, 从而找到哪个进程CPU占用高
2. top -Hp 进程id 查看所有线程CPU占用情况, 从而找到哪个线程CPU占用高
3. jstack 进程id | grep 线程id 查看线程的栈情况
   1. 如果是VM线程, 则是GC线程
   2. 如果是业务线程, 则分析是哪个方法比较慢.

看看是不是处于wait_time的状态.



## 死锁问题定位

jstack 进程id 会直接找到死锁.



## JVM调整参数

| JVM开启关闭类的参数             |                                                           |
| ------------------------------- | --------------------------------------------------------- |
| -XX:+DisableExplicitGC          | 禁止System.GC()                                           |
| -XX:+HeapDumpOnOutOfMemoryError | OOM时生成Dump文件                                         |
| -XX:+PrintGC                    | 打印垃圾回收日志, 生产环境很少打开.                       |
| -XX:+UseXXXGC                   | 使用什么老年代垃圾回收器, 新生代回收器会随着老年代而更改. |



| JVM需要调整的参数                  |                                                              |
| ---------------------------------- | ------------------------------------------------------------ |
| -Xmx, 最大堆大小                   | 一般为操作系统的2/3.                                         |
| -Xms, 初始堆大小                   | 一般设置与最大堆大小一样大, 避免动态扩容. 堆内存扩容优先级低于元空间, 会导致扩容不到最大堆大小. 动态扩容会导致项目启动直接full GC. |
| -Xss, 栈大小                       | 默认1M, 如果局部变量不多, 可设置256k. 栈变小, 可用线程数就增加. 一般不用设置. 因为需要调整的时候服务器也扛不住, 需要加服务器. |
| -XX:+TLABSize                      | 设置TLAB大小.                                                |
| -Xmn, 设置年轻代大小               | G1不设置, 因为G1自动调整年轻代大小和老年代大小比值. 默认新生代占内存大小的1/3. 高并发, 快消亡场景可适当加大, 对半或者更多都是可以的. |
| -XX:SurvivorRatio                  | 设置Eden与两个Suvivor的比值, 默认为8                         |
| -XX:PreTenureSizeThredshold        | 对象多大会直接进入老年代                                     |
| -XX:MaxTenuringThreshold           | 升代年龄                                                     |
| -XX:+ParallelGCThreads             | CMS和PO的并行收集器的线程数, 一般和CPU核数相同, 跟线程池有点关系. |
| -XX:CMSInitiatingOccupancyFraction | 标记线程和业务线程并发运行, 如果垃圾满了, 才需要STW来Full GC. 在并发的时候需要留一些空间, 这些空间用来进行并发标记. |
| -XX:                               | CMS在多少次Full GC后进行压缩.                                |
| -XX:+G1HeapRegionSize              | 单个Region大小                                               |



# JVM调优案例

如何确定多久会产生一次full gc?

假如内存分配情况是 Old2G, Eden800M, S0和S1分别100M.

对比压测, 比如500个请求是150M, 1000个请求是250M, 所以一次请求产生的对象数量是 (250M - 150M) / (1000 - 500) = 0.2M

如果是500/s的请求, 则1s会产生100M对象. 1s就会产生100M

则8s触发一次Young GC. 所以 8s一次STW. Young GC后还剩1s的对象, 也就是100M的垃圾.

<u>而Suvivor是100M, 占用超过了50%, 则会连续升代进入老年代.</u>

也就是每8s会进入100M的老年代.

老年代是2G, 所以20 * 8s会Full GC. 可能会10s+.



如何减少full gc?

增大年轻代大小为1400MB, 增大Suvivor区为300MB. 

14s触发一次Young GC.

300MB可以装下1s的垃圾, 所以不会升代入老年代, 也就不会Full GC.

设置分带年龄为2, 因为Spring Bean生命周期很长, 提早将这些Bean给放到老年代.



