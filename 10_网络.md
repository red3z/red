# TCP/IP网络模型

为了适配不同的设备, 协商出了一套通用的协议.

为什么要对网络协议分层? 解耦.

1. 各层解耦, 便于发现问题解决问题; 
2. 灵活性.  IPV4变为IPV6, 不影响其他层; 
3. 路由器不需要应用层和传输层.
4. 方便测试发现问题从而解决.
5. 标准化.

| TCP/IP网络模型 |                                                              | 协议                         |
| -------------- | ------------------------------------------------------------ | ---------------------------- |
| 应用层         | 应用层不关心数据如何传输, OS工作在用户态, 传输层和以下工作在内核态. | HTTP, DNS, FTP, SMTP, Telnet |
| 传输层         | 负责把数据通过端口传给应用. 建立端到端的 <u>连接</u> .       | TCP, UDP                     |
| 网络层         | 负责数据从一个设备传输到另一个设备.                          | IP协议, ARP                  |
| 网络接口层     | MAC地址                                                      |                              |

HTTP, TCP, Socket的关系是什么?

Socket是TCP/IP网络模型的API, 可以理解为门面.



Http请求在网络模型中的传输过程?

1. 应用层: http协议处理, http的头, http的体
2. 传输层: 附加TCP协议的数据, 包括端口地址.
3. 网络层: 附加IP协议的数据, 包括ip地址, 窗口.
4. 网络接口层: 附加以太网的数据, 包括Mac地址



# 浏览器访问网址过程

| 浏览器访问网址的全过程                        |                                                              |
| --------------------------------------------- | ------------------------------------------------------------ |
| 浏览器解析URL: 协议 + 服务器域名 + 请求的资源 |                                                              |
| 生成HTTP请求: GET请求                         | 请求行(GET + URL + 协议版本) + 请求头 + 请求体               |
| 通过DNS根据域名查询ip.                        | 浏览器缓存 → 操作系统缓存 → hosts 文件 → 本地 DNS 服务器 → 根域名服务器 → 顶级域名服务器 → 权威 DNS 服务器 |
| 操作系统协议栈                                |                                                              |
| TCP                                           |                                                              |
| IP                                            |                                                              |
| MAC                                           |                                                              |
| 网卡                                          | 网卡驱动程序获取到数据后, 将其复制到网卡内的缓冲区中. 网卡负责将二进制数据转换为电信号. |



# Linux收发网络数据过程

网卡收到数据, DMA将数据写入内存的RingBuffer环形缓冲区, 网卡向CPU发起硬件中断, CPU收到中断, 处理受到的网络数据. 

频繁中断效率低, Linux2.6引入NAPI机制, 混合中断和轮询来接受网络包, 用中断唤醒数据接收的程序, poll()轮询数据.

网卡受到数据, DMA将数据写入内存的RingBuffer环形缓冲区, 网卡向CPU发起硬件中断, CPU受到中断, 根据中断表调用已经注册的硬件中断处理函数。

硬件中断处理函数:

- 暂时屏蔽中断
- 发起软中断.

内核中的ksoftirqd线程专门负责软中断处理, ksoftirqd收到软中断后, 轮询处理数据. ksoftirqd线程从RingBuffer中获取一个数据帧sk_buff, 交给网络协议栈逐层处理.

网络接口层: 检查数据合法性, 找出上层协议类型(IPV4还是V6), 去掉帧头帧尾, 交给网络层.

网络层: 取出IP, 判断下一部的走向(是交给上层还是转发出去), 找出上层协议类型(TCP还是UDP), 去掉IP头, 交给传输层.

传输层: 取出TCP/UDP头, 根据端口号找到对应Socket, 把数据放到Socket接收缓冲区.

应用层: 调用Socket接口, 将内核Socket缓冲区拷贝到用户缓冲区, 唤醒用户进程.



# HTTP

Http请求相应包含两个部分, 请求和响应. Http是无状态的, 无法区分是不是一个用户的请求, 通过会话跟踪技术解决无状态问题

| 请求 |                                                              |
| ------ | ------------------------------------------------------------ |
| 请求行 | 请求方式(get, post, put, delete); URI(/search?q=http); 协议(HTTP1.1) |
| 请求头 | Host接收端的IP或域名; Content-Length; Content-Type; Connection(Keep-Alive, 未提出断开连接, 则保持TCP连接); Accept能接受的响应的内容类型 |
| 请求体 |  |

| 响应   |                                                              |
| ------ | ------------------------------------------------------------ |
| 状态行 | 3XX重定向; 4XX客户端错误; 5XX服务端错误                      |
| 响应头 | Content-Type: text/html响应体的数据类型; Content-Length响应体长度; Set-Cookie服务器设置Cookie; |
| 响应体 | 返回的实际数据（如HTML、JSON、图片等）                       |



HTTP1.1的特点

| HTTP1.1的优点 | HTTP1.1的缺点                                                |
| ------------- | ------------------------------------------------------------ |
| 简单          | 无状态, 服务器不需要记录状态信息.                            |
| 灵活          | 明文传输                                                     |
| 应用广泛      | 不安全: 1.明文导致号容易没; 2.没有数据校验导致数据可以被篡改; 3.没有身份验证容易被骗. |



| HTTP各个版本 |                                                              |
| ------------ | ------------------------------------------------------------ |
| 1.1          | 相比1.0使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。支持管道pipeline网络传输, 只要第一个请求发出去了, 就可以发第二个请求出去, 从而减少整体响应时间 |
| 2            | http2是基于https的, 进行了头部压缩, 不再是纯文本, 而是全面采用二进制. 1.1等待响应的过程中没办法干其他事, 会造成队头阻塞的问题. http2服务器可以主动向客户端发送消息. |
| 3            | TCP改为UDP, 没有队头阻塞问题.                                |



HTTP如何优化

减少HTTP请求次数: 

1.HTTP缓存技术; 

2.合并请求, 多个访问小文件的请求合并成一个大的请求, 减少了重复的http头部; 



## HTTPS

https在http基础上用SSL/TLS对数据加密. HTTPS 在TCP三次握手之后, 还需进行SSL/TLS的4次握手过程, 才可进入加密报文传输。

TLS握手 需要2个TLS.



## RPC

HTTP是基于Json序列化的, HTTP请求头会有"Content-Type"这个字符串

RPC定制化程度高, 可以采用体积更小的协议比如Protobuf协议, 也不同考虑浏览器行为比如302重定向, 所以性能更好, 所以服务之间调用使用RPC方式, 而不是用HTTP.

什么是RPC?

Reomote Procedure Call, 远程过程调用

RPC的底层原理?

RPC包含哪些部分?

1. 客户端, 服务端, 建立网络连接模块
2. 服务器处理请求模块
3. 协议处理模块
4. 序列化和反序列化模块



## WebSocket协议

虽然HTTP基于的TCP是全双工的, 但是HTTP用成了半双工.

HTTP1.1中, 只要客户端不问, 服务器就不答. 所以扫码登录明显卡顿, 是因为客户端是通过轮询实现服务器推送的效果.

如果客户端和服务端需要频繁交互, 可以考虑用WebSocket.



# TCP

IP层会分片, 为什么TCP还需要设置最大数据长度?

因为IP层没有超时重传, IP分片的一小块数据丢失, 整个TCP数据都要重发. 所以TCP数据也需要设置MSS(Maximum Segment Size). TCP重发的时候是以MSS为单位.



## TCP头数据

| TCP的内容        |                                                              |
| ---------------- | ------------------------------------------------------------ |
| 源端口和目的端口 |                                                              |
| 序列号seq        | 数据的序号, 保证顺序. TCP面向字节流, 其实也就是对应字节的编号. |
| 确认号ack        | 下一次期望收到的数据序号, 解决丢数据的问题                   |
| 状态位           | ACK, SYN, FIN                                                |
| 窗口大小         |                                                              |
| 时间戳           | 用来计算往返时延; TCP的序列号用完了会重复使用, 用时间戳来区分. |

序列号(标志字节流的顺序), 确认号(期望受到的下一个字节的序号), 窗口大小, SYN(建立连接), FIN(结束连接), ACK

怎么保证可靠? 超时重传.

怎么拥塞控制? 滑动窗口.



## 三次握手

| 三次握手是建立连接的过程                    |                                         |
| ------------------------------------------- | --------------------------------------- |
| 1 客户端问服务端 能不能建立连接?            | 客户端发送SYN, 进入SYN_SENT状态         |
| 2 服务端回复客户端 可以                     | 服务端返回SYN+ACK, 进入SYN_RECEIVED状态 |
| 3 客户端回复服务端 ok, 并且发送第一部分数据 | 客户端发送ACK, 进入ESTABLISHED状态.     |

为什么是三次握手? 避免历史重复连接的干扰.

如果没有第三次握手, 客户端第一次问, 没到达服务端, 客户端第二次问, 建立了连接1.

此时服务端收到了客户端第一次问的请求, 回复给了客户端. 建立了连接2, 此时这个连接2客户端根本不知道.



**什么是半连接队列? 什么是SYN洪泛攻击?**

SYN洪泛攻击: 攻击方伪造假的源地址给我发一堆SYN, 我回复给这些无辜的服务器, 我的服务器里就有一大堆半连接放在半连接队列中.

Linux三次握手的时候, 会维护两个队列:一个是半连接队列SYN队列, 另一个是全连接队队列accept队列

解决方式: 1.将TCB连接控制资源延缓, 本来是第一次握手分配, 延缓后需要做完三次握手分配; 2.防火墙.



**TCP快速打开, TFO的原理?**



## 四次挥手

| 四次挥手连接关闭的过程               |                                                       |
| ------------------------------------ | ----------------------------------------------------- |
| 1 客户端问服务端 能不能关闭连接      | 主动关闭方发送FIN, 进入FIN_WAIT状态                   |
| 2 服务端回复客户端 可以, 等我发送完. | 被动关闭方发返回ACK, 进入CLOSE_WAIT.                  |
| 3 服务端回复客户端 我发送完了        | 被动关闭方发送FIN, 进入LAST_ACK状态.                  |
| 4 客户端回复服务端 ok                | 主动关闭方返回ACK, 进入TIME_WAIT状态, 等待2MSL后关闭, |

为什么要四次挥手? 第三次和第四次能不能合并?

TCP是双向通信, 需要确保两边都发送完了. 如果第三次和第四次合并, 客户端不知道服务端受到没, 会重发, 造成浪费.



等待2MSL, 可以确保原来连接的数据都死掉, 再出现的数据是新的连接, 同时也可以确保被动关闭方关闭.



CLOSE_WAIT原因可能是应用层未正确关闭连接, 也就是未正确调用close()或shutdown()释放Socket.

TIME_WAIT过多原因可能是短连接过多或者内核参数不合理.



**为什么SYN/FIN不包含数据却要消耗序列号?**

因为有了序列号可以保证服务端不会对重复受到的数据进行重复处理, 从而浪费.



**TCP超时重传时间怎么计算?**



**TCP流量控制**









**TCP如何确定消息边界?**

应用程序用自己的规则来确定, 比如Redis的RESP协议.



建立了连接, 客户端崩了和服务端崩了分别会怎样?

客户端崩了: TCP的keep-alive原理是如果7200s没有数据交互则发送探测包检测对方是否存活, 时间太久, 一般在应用层做心跳机制

服务端崩了: 服务端进程崩溃后, 内核需要回收该进程的所有TCP连接资源, 内核会来完成四次挥手.





**常用命令**

telnet www.baidu.com 80 检测一个端口是否打开

netstat 显示网络相关信息

tcpdump 



## TCP的粘包和拆包

TCP的数据没有边界, 是流式协议, 没有分割线. UDP的数据头的数据大小标识了边界.

有时候为了减少网络拥堵, 会积攒数据, 就是粘包. 有时候发送的数据太大会拆分, 就是拆包.

解决粘包拆包的问题是在应用层明确数据包的边界, 让接收方知道每个包的开始和结束.

解决粘包: 1.固定消息长度; 2.特殊字符作为边界; 3.自定义消息结构.



# UDP

UDP报文结构: 源端口, 目的端口, 数据长度, 校验和.

应用于实时游戏, 实时音视频, DNS查询.



# IP

| IP头信息     |                                  |
| ------------ | -------------------------------- |
| 版本号       |                                  |
| 头部长度     |                                  |
| 协议         | ip协议的上层协议, 表示TCP还是UDP |
| 源ip和目的ip |                                  |



# IP相关技术(DNS, ARP.... )

| IP协议相关技术 |          |
| -------------- | -------- |
| DNS            |          |
| ARP            |          |
| DHCP           |          |
| NAT            |          |
| ICMP           | ping命令 |
| IGMP           |          |



# 设备

|                    |                                                              |
| ------------------ | ------------------------------------------------------------ |
| 网关（Gateway）    | 连接不同协议的网络（如TCP/IP与IPX/SPX）。实现协议转换、数据格式转换（如电子邮件网关）。企业内网与外部系统对接。 |
| 路由器             | 承担网关的功能.                                              |
| 网桥（Bridge）     | 连接两个局域网（LAN），基于MAC地址过滤和转发帧。             |
| 交换机（Switch）   | 根据MAC地址表将数据帧精准转发到目标设备端口。                |
| 集线器（Hub）      | 将接收到的信号广播到所有端口。                               |
| 中继器（Repeater） | 仅用于物理层信号增强，不处理数据内容。                       |

